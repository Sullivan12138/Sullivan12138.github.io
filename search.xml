<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kotlin入门</title>
    <url>/2020/10/11/Kotlin%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>编译型语言的特点是编译器会将我们的源代码一次性地编译成计算机可识别的二进制文件，而解释型语言的特点是解释器会一行行地读取我们的源代码然后实时地将他们解释称计算机可识别的二进制数据，所以解释型语言效率差一些。</p>
<p>虽然Java是先编译再运行的，但是Java编译之后生成的并不是计算机可识别的二进制文件，而是一种特殊的class文件，这种文件只有Java虚拟机才能识别，这个Java虚拟机实际上是一种解释器，它将class文件解释成计算机可识别的二进制文件，所以Java实际属于解释型语言。</p>
<p>那么，如果我们开发一门新的语言，将它编译成同样规格的class文件，Java虚拟机能不能识别呢？答案是肯定的。这就是Kotlin语言的工作原理。</p>
<a id="more"></a>
<p>在Android Studio中新建一个kotlin文件，命名为hello-world.kt，输入以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是我们第一个kotlin文件了，它会输出"Hello, world!"</p>
<h2 id="变量">变量</h2>
<p>在Java中如果想要定义一个变量，需要在变量前面声明这个变量的类型。而在Kotlin中只允许在变量前声明两种关键字：<strong>val</strong>和<strong>var</strong>。</p>
<p>val(value)用于声明一个不可变的变量，这种变量在初始赋值以后再也不能重新赋值。var(variable)用于声明一个可变的变量。变量本身的类型由Kotlin的类型推导机制确定。</p>
<p>Kotlin中完全抛弃了Java中的基本数据类型，全部使用了对象数据类型。</p>
<p><strong>永远优先使用val来声明，当val无法满足需求时再用var</strong>。</p>
<p>Kotlin中定义函数的方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个函数中只有一行代码时，Kotlin允许我们不必编写函数体，直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = max(num1, num2)</span><br></pre></td></tr></table></figure>
<p>并且由于类型推导极致，还可以再简化一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = max(num1, num2)</span><br></pre></td></tr></table></figure>
<h2 id="逻辑控制">逻辑控制</h2>
<h3 id="if语句">if语句</h3>
<p>kotlin中的if可以有返回值，返回值就是if语句每一个条件中最后一行代码的返回值</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-10-11杂谈</title>
    <url>/2020/10/11/2020-10-11%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>Python中三个有用的函数：</p>
<ul>
<li>max()，可以传入数组，直接返回数组的最大值，与之对应的还有min()</li>
<li>enumerate()，可以传入数组，返回(i, num)的序列，其中i为下标，num为数组对应下标处的元素，可以用于for循环</li>
<li>sum()，可以传入数组，直接返回数组元素之和</li>
</ul>
<p>另外，Python中//表示除法向下取整，类似C语言里的除法，Python里面的/是返回浮点数的。</p>
<p>定义一个一维全0数组可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>] * n</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>每日杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin空指针</title>
    <url>/2020/10/04/Kotlin%E7%A9%BA%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>Kotlin中默认所有参数和变量都非空，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doStudy(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会报错，因为传入了空指针。</p>
<a id="more"></a>
<p>要想定义可以为空的参数或变量，需要在类型名后面加上?，上述代码改成下面这样就可以了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这时study的两个方法又会报错，因为这时可以传入空指针了，编译器会暗示我们进行空指针检查，我们可以用?.运算符，这个运算符表示如果为空就不执行返回Null，如果非空就执行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">study?.readBooks()</span><br><span class="line">study?.doHomework()</span><br></pre></td></tr></table></figure>
<p>另外还有?:运算符，这个运算符表示如果左边的语句非空就返回左边的执行结果，否则返回右边的执行结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a?:b</span><br><span class="line">表示</span><br><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!!是非空断言语句，表示我们告诉编译器它前面的对象就是非空的，不需要空指针检查。</p>
<p>let是Kotlin一个内置函数，它将调用它的变量传入后面的lambda表达式中。它可以用来和?.结合。</p>
<p>上述的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">study?.readBooks()</span><br><span class="line">study?.doHomework()</span><br></pre></td></tr></table></figure>
<p>实际上执行了两次if else判断，用let可以简化</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">study?.let &#123; stu -&gt;</span><br><span class="line">           stu.readBooks()</span><br><span class="line">           stu.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断study是否非空，如果非空就执行let函数，将study传入，执行后面的两个函数</p>
<p>此外let可以用于处理全局变量的判空问题，但是if不可以。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发学习笔记（一）</title>
    <url>/2020/10/07/Android%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="文件结构">文件结构</h2>
<p>app/src/main/java目录下存放所有的java代码和Kotlin代码。app/src/main/AndroidManifest.xml是整个Android项目的配置文件，程序中定义的四大组件（Activity、Service、BroadcastReceiver、ContentProvider）都要在这里注册了以后才能用。app/src/main/res目录下，以drawable开头的文件夹存放着图片，以mipmap开头的存放着图标，以values开头的存放着字符串、样式、颜色等配置，以layout开头的存放着布局文件。所有界面都是通过XML文件编写出来的。</p>
<a id="more"></a>
<h2 id="声明activity">声明Activity</h2>
<p>Activity是一种可以包含用户界面的组件，主要用于和用户进行交互。一个应用程序可以包含0个或多个Activity，但是不包含Activity的应用程序很少见。</p>
<p>项目中任何Activity都要重写onCreate()方法。每一个Activity最好都要对应一个布局文件。</p>
<p>Activity必须要在AndroidManifest.xml文件中注册，注册的方法为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过一般Android Studio会自动帮我们创建。上面的android:name用来指定注册哪一个Activity，而.FirstActivity是com.example.activitytest.FirstActivity的缩写写。因为AndroidManifest.xml文件已经在最外层的 &lt;manifest&gt; 中指定了包名，所以这里可以省略包名。</p>
<p>配置主Activity的方式是在&lt;activity&gt;标签内部加上&lt;intent-filter&gt;标签，并在其中加上<code>&lt;action android:name="android.intent.action.MAIN" /&gt;         &lt;category android:name="android.intent.category.LAUNCHER" /&gt;</code>此外还可以用android:label属性指定Activity标题栏的内容，标题栏显示在Activity最顶部，而且会成为启动器（Launcher）中应用程序显示的名称。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android</span> <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:label</span>=<span class="string">&quot;This is FirstActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果没有声明主Activity，这个应用程序就不能运行，但是可以作为库文件被其他应用程序调用。</p>
<h2 id="toast">Toast</h2>
<p>Toast是一种提醒方式，过一段时间后会消失，并且不会占用任何屏幕空间。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> button1: Button = findViewById(R.id.button1)</span><br><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You clicked Button 1&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findViewById()用于获取布局文件中定义的元素，这个id是在XML文件中的<code>&lt;android:id="@+id/button1"</code>定义的。findViewById返回的是一个继承自View的泛型对象，Kotlin无法自动推导出它是Button还是其他控件，因此需要强制类型转换。</p>
<p>Toast的用法很简单，通过静态方法makeText()方法创建一个Toast对象，然后调用show()方法将Toast显示出来。makeText()需要传入3个参数，第一个是context，也就是Toast要求的上下文，由于Activity本身就是一个Context对象，因此直接传入this即可。第二个是Toast显示的文本内容，第三个是显示的时长，有两个内置常量可以选择：Toast.LENGTH_SHORT和Toast.LENGTH_LONG</p>
<p>Kotlin编写的Android项目在app/build.gradle文件的头部默认引入了一个kotlin-android-extensions插件，这个插件会根据布局文件中定义的控件id自动生成一个具有相同名称的变量，我们可以在Activity中直接使用这些变量，就不再需要findViewById()方法了。当然还是建议使用Android Studio的自动补全功能，因为这些自动生成的变量也是需要导包的。</p>
<h2 id="menu">Menu</h2>
<p>menu通过Android Studio中Menu resource file文件创建，它的xml文件开头是<code>&lt;menu&gt;</code>标签，而AndroidManifest.xml开头是<code>&lt;manifest&gt;</code>标签，layout文件开头是<code>&lt;Layout&gt;</code>标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_item&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:title</span>=<span class="string">&quot;Add&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/remove_item&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:title</span>=<span class="string">&quot;Remove&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;item&gt;</code>标签用于创建一个菜单项，通过<code>&lt;android:id&gt;</code>给这个菜单项指定一个id，通过<code>&lt;android:title&gt;</code>给这个菜单项指定一个名称。</p>
<p>然后需要重写onCreateOptionsMenu()方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    menuInflater.inflate(R.menu.main, menu)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>menuInflater实际上是调用了父类的getMenuInflater()方法，返回一个menuInflater对象。它的inflate()方法接受两个参数，第一个参数用于指定我们通过哪个资源文件来创建菜单，第二个参数用于指定我们的菜单项添加到哪个Menu对象之中，这里我们直接使用onCreateOptionsMenu()方法中传入的menu参数。最后返回true表示将菜单显示出来。</p>
<p>通过重写onOptionsItemSelected()方法来定义当我们点击菜单时的响应事件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">        R.id.add_item -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You clicked Add&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        R.id.remove_item -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You clicked Remove&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>item.itemId</code>判断点击的是哪个菜单项</p>
<h2 id="销毁activity">销毁Activity</h2>
<p>按下back键可以销毁，也可以在代码中调用finish()方法销毁。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode416题解</title>
    <url>/2020/10/11/leetcode416%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100 数组的大小不会超过 200</p>
<p>示例 1:</p>
<p>输入: [1, 5, 11, 5]</p>
<p>输出: true</p>
<p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<p>示例 2:</p>
<p>输入: [1, 2, 3, 5]</p>
<p>输出: false</p>
<p>解释: 数组不能分割成两个元素和相等的子集.</p>
<a id="more"></a>
<h2 id="题解">题解</h2>
<p><strong>本题是一个NP完全问题！！！</strong>所以想在多项式时间内完成是不可能的，我们必须尝试非多项式时间复杂度的算法，例如时间复杂度与元素大小相关的<strong>动态规划</strong>。实际上，这道题可以换一种表述：给定一个只包含正整数的非空数组 [0]nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。因此这个问题可以转换成「0−1 背包问题」。这道题与传统的「0−1 背包问题」的区别在于，传统的「0−1 背包问题」要求选取的物品的重量之和不能超过背包的总容量，这道题则要求选取的数字的和恰好等于整个数组的元素和的一半。类似于传统的「0−1 背包问题」，可以使用动态规划求解。</p>
<p>在使用动态规划求解之前，首先需要进行以下判断。</p>
<p>根据数组的长度 n 判断数组是否可以被划分。如果 n&lt;2，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。</p>
<p>计算整个数组的元素和 sum 以及最大元素 maxNum。如果sum 是奇数，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。如果sum 是偶数，则令 target=sum/2，需要判断是否可以从数组中选出一些数字，使得这些数字的和等于target。如果 maxNum&gt;target，则除了maxNum 以外的所有元素之和一定小于target，因此不可能将数组分割成元素和相等的两个子集，直接返回 false。</p>
<p>创建二维数组 dp，包含 n 行target+1 列，其中 dp[i][j] 表示从数组的[0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。</p>
<p>在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。</p>
<p>如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有0≤i&lt;n，都有dp[i][0]=true。</p>
<p>当i==0 时，只有一个正整数nums[0] 可以被选取，因此dp[i][0]=true。</p>
<p>对于 i&gt;0且j&gt;0 的情况，如何确定dp[i][j] 的值？需要分别考虑以下两种情况。</p>
<p>如果j≥nums[i]，则对于当前的数字nums[i]，可以选取也可以不选取，两种情况只要有一个为 true，就有dp[i][j]=true。</p>
<p>如果不选取nums[i]，则dp[i][j]=dp[i−1][j]； 如果选取nums[i]，则 dp[i][j]=dp[i−1][j−nums[i]]。 如果 j &lt;nums[i]，则在选取的数字的和等于 j 的情况下无法选取当前的数字nums[i]，因此有dp[i][j]=dp[i−1][j]。</p>
<p>状态转移方程如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjl2uugoisj30vk044mxk.jpg" /></p>
<p>最终得到 dp[n−1][target] 即为答案。</p>
<p>但是可以发现在计算dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjl2v7hzz6j30g802kgln.jpg" /></p>
<p>且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新dp 值，那么在计算dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的dp 值。</p>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">题解来源</a></p>
<h2 id="代码">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        total = sum(nums)</span><br><span class="line">        maxNum = max(nums)</span><br><span class="line">        target = total // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> <span class="keyword">or</span> maxNum &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * target</span><br><span class="line">        <span class="keyword">for</span> _, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, num - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] |= dp[j - num]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>latex学习笔记（一）</title>
    <url>/2020/10/15/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>latex分数：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">frac</span><span class="string">&#123;分子&#125;</span><span class="string">&#123;分母&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>latex小于等于:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">leq</span></span>或<span class="tag">\<span class="name">le</span></span></span><br></pre></td></tr></table></figure>
<p>大于等于：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">geq</span></span>或<span class="tag">\<span class="name">ge</span></span></span><br></pre></td></tr></table></figure>
<p>Mac下可以将输入法切换为希腊文来打希腊字母</p>
<p>不等于：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">ne</span></span></span><br></pre></td></tr></table></figure>
<p>大括号：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">LeakyReLU=<span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;lr&#125;</span></span></span><br><span class="line">x&amp;x<span class="tag">\<span class="name">geq</span></span>0  <span class="tag">\<span class="name">\</span></span></span><br><span class="line">px&amp;x&lt;0 </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">right</span></span>.</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><span class="math display">\[LeakyReLU=\left\{
\begin{array}{lr}
x&amp;x\geq0  \\
px&amp;x&lt;0 
\end{array}
\right.\]</span></p>
<p>去mathjax.org可以在线将latex转为mathML，然后可以直接拷贝到word中变成公式，然后就可以拷贝到ppt中。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>论文写作</tag>
        <tag>word</tag>
        <tag>ppt</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow学习笔记（一）</title>
    <url>/2020/09/29/tensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="创建张量">创建张量</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant(<span class="number">1.2</span>) <span class="comment"># 创建一个0维张量，也叫标量，shape为[]</span></span><br><span class="line">tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 创建一个1维张量，也叫向量，shape为[3]</span></span><br><span class="line">tf.constant([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>]]) <span class="comment"># 创建一个2维张量，也叫矩阵，shape为[2, 2]</span></span><br><span class="line">tf.constant([[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]], [[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>]]]) <span class="comment"># 创建一个3维张量，shape为[2, 2, 2]</span></span><br></pre></td></tr></table></figure>
<p>1维及以上的张量都要用list来创建。</p>
<p>另外，还支持传入字符串和布尔类型变量来创建张量。但是tensorflow类型的布尔变量和python内置类型的布尔变量并不相等。</p>
<a id="more"></a>
<p>可以用dtype参数指定传入数据的精度，访问张量的dtype变量可以获得它的数据精度。</p>
<p>使用<code>tf.cast(tensor, dtype)</code>改变张量的精度，其中，tensor表示待转换数据精度的张量，dtype表示将其转换成的精度。转换时，要注意可能发生的溢出错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant(<span class="number">12345678</span>, dtype=int32) <span class="comment"># 组成a的数据精度被指定为int32</span></span><br><span class="line">print(a.dtype) <span class="comment"># 结果为int32</span></span><br><span class="line">a = tf.cast(a, dtype=double) <span class="comment"># 将a的数据精度改为double</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>tf.convert_to_tensor()</code>也可以将Numpry Array和Python List对象转化为张量，其用法和<code>tf.constant()</code>一样，二者功能也一样。</p>
<h2 id="创建待优化张量">创建待优化张量</h2>
<p>为了区分需要计算梯度信息的张量与不需要计算梯度信息的张量，TensorFlow 增加了 一种专门的数据类型来支持梯度信息的记录：tf.Variable。tf.Variable 类型在普通的张量类 型基础上添加了 name，trainable 等属性来支持计算图的构建。由于梯度运算会消耗大量的 计算资源，而且会自动更新相关参数，对于不需要的优化的张量，如神经网络的输入𝑿， 不需要通过 tf.Variable 封装；相反，对于需要计算梯度并优化的张量，如神经网络层的𝑾 和𝒃，需要通过 tf.Variable 包裹以便TensorFlow跟踪相关梯度信息。</p>
<p>可以将普通张量传入来创建，也可以直接创建。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">aa = tf.Variable(a)</span><br><span class="line">aaa = tf.Variable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(a.trainable) <span class="comment"># trainable变量表示是否需要优化，对于待优化张量，这个值一般为True，也可以设置为False</span></span><br></pre></td></tr></table></figure>
<h2 id="其余常用创建方法">其余常用创建方法</h2>
<h3 id="创建全0或全1张量">创建全0或全1张量</h3>
<h2 id="拼接函数">拼接函数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.concat(tensors, axis)</span><br></pre></td></tr></table></figure>
<p>其中，tensors表示需要拼接的张量，axis表示在哪一个维度上拼接，要求非拼接的维度必须一致。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>])</span><br><span class="line">b = tf.random.normal([<span class="number">6</span>, <span class="number">6</span>, <span class="number">10</span>])</span><br><span class="line">c = tf.concat([a, b], axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># c的shape为(10, 6, 10)</span></span><br></pre></td></tr></table></figure>
<h2 id="堆叠函数">堆叠函数</h2>
<p>拼接函数直接在现有维度上合并，不创建新的维度，如果需要创建新的维度，使用堆叠函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.stack(tensors, axis)</span><br></pre></td></tr></table></figure>
<p>其中，tensors表示需要堆叠的张量，axis表示新维度插入的维度，当axis&gt;=0时，插入在该维度之前，当axis&lt;0时，插入在该维度之后。</p>
<p>堆叠函数需要所有被堆叠的张量维度都一致。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">35</span>, <span class="number">8</span>])</span><br><span class="line">b = tf.random.normal([<span class="number">35</span>, <span class="number">8</span>])</span><br><span class="line">c = tf.stack([a, b], axis=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># c的shape为(35, 8, 2)</span></span><br></pre></td></tr></table></figure>
<h2 id="分割函数">分割函数</h2>
<p>分割函数是拼接的逆函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.split(x, num_or_size_splits, axis)</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>x表示待分割张量</li>
<li>num_or_size_splits表示切割方案。当其为单个值时，如10，表示等长切割为10份。当其为List时，表示按list的结构去分割。</li>
<li>axis表示指定在哪个维度进行分割</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">10</span>, <span class="number">35</span>, <span class="number">8</span>])</span><br><span class="line">result = tf.split(a, <span class="number">10</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># result长度为10，其中每个元素的shape为(1, 35, 8)</span></span><br><span class="line">result2 = tf.split(a, [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># result2长度为4，其中4个元素的shape分别为(4, 35, 8), (2, 35, 8), (2, 35, 8), (2, 35, 8)</span></span><br></pre></td></tr></table></figure>
<p>特别地，如果希望在某个维度上全部按长度为 1 的方式分割，还可以使用 <code>tf.unstack(x, axis)</code>函数。这种方式是 tf.split 的一种特殊情况，切割长度固定为 1，只需要指定切割维度 的索引号即可。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
</search>
